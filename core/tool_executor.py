#!/usr/bin/env python3
from utils.windows_compat import safe_print
# -*- coding: utf-8 -*-
"""
å·¥å…·æ‰§è¡Œå™¨ - é€šè¿‡HTTPè°ƒç”¨toolServer
å‚è€ƒåŸé¡¹ç›®tool_utils.pyçš„é€»è¾‘
"""

import requests
import yaml
import json
import time
import uuid
from typing import Dict, Any
from pathlib import Path


class ToolExecutor:
    """å·¥å…·æ‰§è¡Œå™¨ - é€šè¿‡HTTPè°ƒç”¨toolServer"""
    
    # å±é™©å·¥å…·åˆ—è¡¨ï¼ˆéœ€è¦ç”¨æˆ·ç¡®è®¤ï¼‰
    DANGEROUS_TOOLS = [
        "file_write",      # æ–‡ä»¶å†™å…¥
        "pip_install",     # å®‰è£…åŒ…
        "execute_code",    # æ‰§è¡Œä»£ç 
    ]
    
    def __init__(self, config_loader, hierarchy_manager):
        """
        åˆå§‹åŒ–å·¥å…·æ‰§è¡Œå™¨
        
        Args:
            config_loader: é…ç½®åŠ è½½å™¨
            hierarchy_manager: å±‚çº§ç®¡ç†å™¨
        """
        self.config_loader = config_loader
        self.hierarchy_manager = hierarchy_manager
        self.task_cache = {}  # ç¼“å­˜å·²åˆ›å»ºçš„ä»»åŠ¡
        
        # ä»tool_config.yamlè¯»å–toolServer URL
        self.tools_server_url = self._load_tools_server_url()
        
        # æƒé™ç®¡ç†ï¼štask_id â†’ auto_mode æ˜ å°„
        self.task_permissions = {}  # {task_id: {"auto_mode": True/False}}
    
    def _load_tools_server_url(self) -> str:
        """ä»é…ç½®æ–‡ä»¶åŠ è½½å·¥å…·æœåŠ¡å™¨URL"""
        try:
            project_root = Path(__file__).parent.parent
            config_path = project_root / "config" / "run_env_config" / "tool_config.yaml"
            
            with open(config_path, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
                url = config.get('tools_server', 'http://127.0.0.1:8001/')
                # ç§»é™¤æœ«å°¾çš„æ–œæ 
                return url.rstrip('/')
        except Exception as e:
            safe_print(f"âš ï¸ åŠ è½½å·¥å…·æœåŠ¡å™¨é…ç½®å¤±è´¥: {e}ï¼Œä½¿ç”¨é»˜è®¤å€¼")
            return "http://127.0.0.1:8001"
    
    def set_task_permission(self, task_id: str, auto_mode: bool):
        """è®¾ç½®ä»»åŠ¡çš„æƒé™æ¨¡å¼"""
        self.task_permissions[task_id] = {"auto_mode": auto_mode}
        safe_print(f"ğŸ” ä»»åŠ¡æƒé™è®¾ç½®: {task_id} â†’ auto_mode={auto_mode}")
    
    def is_auto_mode(self, task_id: str) -> bool:
        """æ£€æŸ¥ä»»åŠ¡æ˜¯å¦ä¸ºè‡ªåŠ¨æ¨¡å¼ï¼ˆé»˜è®¤ Trueï¼‰"""
        return self.task_permissions.get(task_id, {}).get("auto_mode", True)
    
    def _ensure_task_exists(self, task_id: str):
        """ç¡®ä¿ä»»åŠ¡åœ¨toolServerä¸­å­˜åœ¨"""
        if task_id in self.task_cache:
            return
        
        try:
            # URL ç¼–ç  task_idï¼ˆé¿å…è·¯å¾„ä¸­çš„ç‰¹æ®Šå­—ç¬¦å’ŒåŒæ–œæ é—®é¢˜ï¼‰
            from urllib.parse import quote
            encoded_task_id = quote(task_id, safe='')
            
            # æ£€æŸ¥ä»»åŠ¡çŠ¶æ€ï¼ˆç¡®ä¿ URL æ ¼å¼æ­£ç¡®ï¼‰
            status_url = f"{self.tools_server_url}/api/task/{encoded_task_id}/status"
            response = requests.get(status_url, timeout=5)
            
            if response.status_code == 200:
                self.task_cache[task_id] = True
                return
            
            # ä»»åŠ¡ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒ
            create_url = f"{self.tools_server_url}/api/task/create"
            params = {"task_id": task_id, "task_name": f"MLA-V3-{task_id}"}
            create_response = requests.post(create_url, params=params, timeout=10)
            
            if create_response.status_code == 200:
                safe_print(f"âœ… ä»»åŠ¡ '{task_id}' å·²åœ¨toolServerä¸­åˆ›å»º")
                self.task_cache[task_id] = True
            else:
                safe_print(f"âš ï¸ åˆ›å»ºä»»åŠ¡å¤±è´¥: {create_response.text}")
        
        except Exception as e:
            safe_print(f"âš ï¸ æ£€æŸ¥/åˆ›å»ºä»»åŠ¡æ—¶å‡ºé”™: {e}")
    
    def _request_tool_confirmation(self, tool_name: str, arguments: Dict[str, Any], task_id: str) -> bool:
        """
        è¯·æ±‚å·¥å…·æ‰§è¡Œç¡®è®¤
        
        Returns:
            True - ç”¨æˆ·æ‰¹å‡†æ‰§è¡Œ
            False - ç”¨æˆ·æ‹’ç»æ‰§è¡Œ
        """
        try:
            # ç”Ÿæˆå”¯ä¸€ç¡®è®¤ID
            confirm_id = f"confirm_{tool_name}_{int(time.time())}_{uuid.uuid4().hex[:8]}"
            
            # åˆ›å»ºç¡®è®¤è¯·æ±‚
            create_url = f"{self.tools_server_url}/api/tool-confirmation/create"
            create_payload = {
                "confirm_id": confirm_id,
                "task_id": task_id,
                "tool_name": tool_name,
                "arguments": arguments
            }
            
            response = requests.post(create_url, json=create_payload, timeout=5)
            if response.status_code != 200:
                safe_print(f"âš ï¸  åˆ›å»ºç¡®è®¤è¯·æ±‚å¤±è´¥ï¼Œé»˜è®¤æ‹’ç»æ‰§è¡Œ")
                return False
            
            safe_print(f"â¸ï¸  ç­‰å¾…ç”¨æˆ·ç¡®è®¤: {tool_name}")
            
            # è½®è¯¢ç­‰å¾…ç”¨æˆ·å“åº”ï¼ˆæœ€å¤šç­‰å¾… 300 ç§’ï¼‰
            max_wait = 300
            check_interval = 2
            elapsed = 0
            
            status_url = f"{self.tools_server_url}/api/tool-confirmation/{confirm_id}"
            
            while elapsed < max_wait:
                time.sleep(check_interval)
                elapsed += check_interval
                
                try:
                    status_response = requests.get(status_url, timeout=5)
                    if status_response.status_code == 200:
                        result = status_response.json()
                        
                        if result.get("found") and result.get("status") == "completed":
                            approved = result.get("result") == "approved"
                            if approved:
                                safe_print(f"âœ… ç”¨æˆ·æ‰¹å‡†æ‰§è¡Œ: {tool_name}")
                            else:
                                safe_print(f"âŒ ç”¨æˆ·æ‹’ç»æ‰§è¡Œ: {tool_name}")
                            return approved
                except Exception:
                    continue
            
            # è¶…æ—¶ï¼Œé»˜è®¤æ‹’ç»
            safe_print(f"â±ï¸  ç¡®è®¤è¶…æ—¶ï¼Œæ‹’ç»æ‰§è¡Œ: {tool_name}")
            return False
            
        except Exception as e:
            safe_print(f"âŒ ç¡®è®¤è¯·æ±‚å¤±è´¥: {e}ï¼Œæ‹’ç»æ‰§è¡Œ")
            return False
    
    def execute(self, tool_name: str, arguments: Dict[str, Any], task_id: str) -> Dict:
        """
        æ‰§è¡Œå·¥å…·è°ƒç”¨
        
        Args:
            tool_name: å·¥å…·åç§°
            arguments: å·¥å…·å‚æ•°
            task_id: ä»»åŠ¡ID
            
        Returns:
            æ‰§è¡Œç»“æœå­—å…¸
        """
        try:
            # è·å–å·¥å…·é…ç½®
            tool_config = self.config_loader.get_tool_config(tool_name)
            tool_type = tool_config.get("type")
            
            # ç‰¹æ®Šå¤„ç†final_output
            if tool_name == "final_output":
                return {
                    "status": arguments.get("status", "success"),
                    "output": arguments.get("output", ""),
                    "error_information": arguments.get("error_information", "")
                }
            
            # åˆ¤æ–­æ˜¯æ™®é€šå·¥å…·è¿˜æ˜¯å­Agent
            if tool_type == "tool_call_agent":
                # æ£€æŸ¥æ˜¯å¦ä¸ºå±é™©å·¥å…·ä¸”éœ€è¦ç¡®è®¤
                if tool_name in self.DANGEROUS_TOOLS and not self.is_auto_mode(task_id):
                    # è¯·æ±‚ç”¨æˆ·ç¡®è®¤
                    approved = self._request_tool_confirmation(tool_name, arguments, task_id)
                    
                    if not approved:
                        # ç”¨æˆ·æ‹’ç»æ‰§è¡Œ
                        return {
                            "status": "error",
                            "output": "",
                            "error_information": f"å·¥å…·æ‰§è¡Œè¢«ç”¨æˆ·æ‹’ç»: {tool_name}"
                        }
                
                # æ™®é€šå·¥å…· - é€šè¿‡HTTPè°ƒç”¨toolServer
                return self._call_toolserver(tool_name, arguments, task_id)
            
            elif tool_type == "llm_call_agent":
                # å­Agent - é€’å½’è°ƒç”¨
                # æ³¨æ„ï¼šuuid å·²åœ¨ agent_executor ä¸­æ·»åŠ ï¼ˆä»…å¯¹ level != 0ï¼‰
                return self._execute_sub_agent(tool_name, tool_config, arguments, task_id)
            
            else:
                return {
                    "status": "error",
                    "output": "",
                    "error_information": f"ä¸æ”¯æŒçš„å·¥å…·ç±»å‹: {tool_type}"
                }
        
        except Exception as e:
            return {
                "status": "error",
                "output": "",
                "error_information": f"å·¥å…·æ‰§è¡Œå¤±è´¥: {str(e)}"
            }
    
    def _call_toolserver(self, tool_name: str, arguments: Dict, task_id: str) -> Dict:
        """é€šè¿‡HTTPè°ƒç”¨toolServeræ‰§è¡Œå·¥å…·"""
        try:
            # ç¡®ä¿ä»»åŠ¡å­˜åœ¨
            self._ensure_task_exists(task_id)
            
            # æ„å»ºè¯·æ±‚
            execute_url = f"{self.tools_server_url}/api/tool/execute"
            payload = {
                "task_id": task_id,
                "tool_name": tool_name,
                "params": arguments
            }
            
            headers = {
                'Content-Type': 'application/json; charset=utf-8',
                'Accept': 'application/json; charset=utf-8'
            }
            
            safe_print(f"   ğŸ”— è°ƒç”¨toolServer: {tool_name}")
            
            # å‘é€è¯·æ±‚
            response = requests.post(
                execute_url,
                json=payload,
                headers=headers,
                timeout=100000
            )
            response.raise_for_status()
            
            # è§£æå“åº”
            tool_server_response = response.json()
            
            if tool_server_response.get("success"):
                output_data = tool_server_response.get("data", {})
                return {
                    "status": "success",
                    "output": json.dumps(output_data, indent=2, ensure_ascii=False),
                    "error_information": ""
                }
            else:
                error_msg = tool_server_response.get("error", "å·¥å…·æœåŠ¡å™¨è¿”å›æœªçŸ¥é”™è¯¯")
                return {
                    "status": "error",
                    "output": "",
                    "error_information": error_msg
                }
        
        except Exception as e:
            return {
                "status": "error",
                "output": "",
                "error_information": f"è°ƒç”¨toolServerå¤±è´¥: {str(e)}"
            }
    
    def _execute_sub_agent(
        self,
        agent_name: str,
        agent_config: Dict,
        arguments: Dict,
        task_id: str
    ) -> Dict:
        """æ‰§è¡Œå­Agentè°ƒç”¨"""
        try:
            # å¯¼å…¥Agentæ‰§è¡Œå™¨ï¼ˆé¿å…å¾ªç¯å¯¼å…¥ï¼‰
            from core.agent_executor import AgentExecutor
            
            # è·å–ä»»åŠ¡è¾“å…¥
            task_input = arguments.get("task_input", "")
            
            # åˆ›å»ºå­Agentæ‰§è¡Œå™¨
            sub_agent = AgentExecutor(
                agent_name=agent_name,
                agent_config=agent_config,
                config_loader=self.config_loader,
                hierarchy_manager=self.hierarchy_manager
            )
            
            # æ‰§è¡Œå­Agent
            result = sub_agent.run(task_id, task_input)
            
            return result
        
        except Exception as e:
            import traceback
            error_detail = traceback.format_exc()
            safe_print(f"âŒ å­Agentæ‰§è¡Œå¤±è´¥: {e}")
            safe_print(f"è¯¦ç»†é”™è¯¯:\n{error_detail}")
            return {
                "status": "error",
                "output": "",
                "error_information": f"å­Agentæ‰§è¡Œå¤±è´¥: {str(e)}\n{error_detail}"
            }


if __name__ == "__main__":
    from utils.config_loader import ConfigLoader
    from core.hierarchy_manager import get_hierarchy_manager
    
    # æµ‹è¯•å·¥å…·æ‰§è¡Œå™¨
    config_loader = ConfigLoader("infiHelper")
    hierarchy_manager = get_hierarchy_manager("test_task")
    
    executor = ToolExecutor(config_loader, hierarchy_manager)
    safe_print(f"âœ… å·¥å…·æ‰§è¡Œå™¨åˆå§‹åŒ–æˆåŠŸ")
    safe_print(f"   ToolServer URL: {executor.tools_server_url}")
    
    # æµ‹è¯•final_output
    result = executor.execute("final_output", {
        "task_id": "test",
        "status": "success",
        "output": "æµ‹è¯•å®Œæˆ"
    }, "test_task")
    
    safe_print(f"âœ… final_outputæµ‹è¯•: {result}")
